<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lxyzk.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="最近学习Android开发，了解到Java中可以使用synchronized块进行线程同步。因此来探究一下在Android中，synchronized是怎么实现的。">
<meta property="og:type" content="article">
<meta property="og:title" content="synchronized实现原理探究">
<meta property="og:url" content="http://lxyzk.github.io/2022/07/30/art-java-synchronized-expore/index.html">
<meta property="og:site_name" content="Xiangxin">
<meta property="og:description" content="最近学习Android开发，了解到Java中可以使用synchronized块进行线程同步。因此来探究一下在Android中，synchronized是怎么实现的。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-29T16:22:28.000Z">
<meta property="article:modified_time" content="2022-07-29T16:54:53.813Z">
<meta property="article:author" content="刘相鑫">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="ART">
<meta property="article:tag" content="Thread">
<meta property="article:tag" content="Synchronized">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lxyzk.github.io/2022/07/30/art-java-synchronized-expore/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://lxyzk.github.io/2022/07/30/art-java-synchronized-expore/","path":"2022/07/30/art-java-synchronized-expore/","title":"synchronized实现原理探究"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>synchronized实现原理探究 | Xiangxin</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Xiangxin</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95Demo"><span class="nav-number">1.</span> <span class="nav-text">简单Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">字节码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ART%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">ART源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MonitorEnter-%E5%8A%A0%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">MonitorEnter 加锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-MonitorEnter"><span class="nav-number">2.1.1.</span> <span class="nav-text">Monitor::MonitorEnter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-InflateThinLocked"><span class="nav-number">2.1.2.</span> <span class="nav-text">Monitor::InflateThinLocked</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-Inflate"><span class="nav-number">2.1.3.</span> <span class="nav-text">Monitor::Inflate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-Lock"><span class="nav-number">2.1.4.</span> <span class="nav-text">Monitor::Lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-TryLock"><span class="nav-number">2.1.5.</span> <span class="nav-text">Monitor::TryLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutex-ExclusiveTryLock"><span class="nav-number">2.1.6.</span> <span class="nav-text">Mutex::ExclusiveTryLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutex-ExclusiveTryLockWithSpinning"><span class="nav-number">2.1.7.</span> <span class="nav-text">Mutex::ExclusiveTryLockWithSpinning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutex-ExclusiveLock"><span class="nav-number">2.1.8.</span> <span class="nav-text">Mutex::ExclusiveLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MonitorExit-%E9%87%8A%E6%94%BE%E9%94%81"><span class="nav-number">2.2.</span> <span class="nav-text">MonitorExit 释放锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-MonitorExit"><span class="nav-number">2.2.1.</span> <span class="nav-text">Monitor::MonitorExit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-Unlock"><span class="nav-number">2.2.2.</span> <span class="nav-text">Monitor::Unlock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-SignalWaiterAndReleaseMonitorLock"><span class="nav-number">2.2.3.</span> <span class="nav-text">Monitor::SignalWaiterAndReleaseMonitorLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutex-Unlock"><span class="nav-number">2.2.4.</span> <span class="nav-text">Mutex::Unlock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wait"><span class="nav-number">2.3.</span> <span class="nav-text">Wait</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-wait-Java"><span class="nav-number">2.3.1.</span> <span class="nav-text">Object.wait() [Java]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-waitWaitJI"><span class="nav-number">2.3.2.</span> <span class="nav-text">Object_waitWaitJI()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#art-mirror-Object-Wait"><span class="nav-number">2.3.3.</span> <span class="nav-text">art::mirror::Object::Wait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-Monitor-Wait"><span class="nav-number">2.3.4.</span> <span class="nav-text">static Monitor::Wait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-Wait"><span class="nav-number">2.3.5.</span> <span class="nav-text">Monitor::Wait</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Notify"><span class="nav-number">2.4.</span> <span class="nav-text">Notify</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-notify-java"><span class="nav-number">2.4.1.</span> <span class="nav-text">Object.notify() [java]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-notify"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">Object_notify</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#art-mirror-Object-Notify"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">art::mirror::Object::Notify</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static-Monitor-Notify"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">static Monitor::Notify</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Monitor-DoNotify"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">Monitor::DoNotify</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Monitor-Notify"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">Monitor::Notify</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-notifyAll-java"><span class="nav-number">2.4.2.</span> <span class="nav-text">Object.notifyAll() [java]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-notifyAll"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">Object_notifyAll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#art-mirror-Object-NotifyAll"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">art::mirror::Object::NotifyAll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static-Monitor-NotifyAll"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">static Monitor::NotifyAll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Monitor-NotifyAll"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">Monitor::NotifyAll</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘相鑫</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lxyzk.github.io/2022/07/30/art-java-synchronized-expore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘相鑫">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiangxin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="synchronized实现原理探究 | Xiangxin">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          synchronized实现原理探究
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-07-30 00:22:28 / 修改时间：00:54:53" itemprop="dateCreated datePublished" datetime="2022-07-30T00:22:28+08:00">2022-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>最近学习Android开发，了解到Java中可以使用synchronized块进行线程同步。<br>因此来探究一下在Android中，synchronized是怎么实现的。</p>
<span id="more"></span>

<h2 id="简单Demo"><a href="#简单Demo" class="headerlink" title="简单Demo"></a>简单Demo</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>使用到synchronized块的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mVal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mVal = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的Java代码编译后的Dex字节码如下：</p>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods</span><br><span class="line">.method public testSync()V</span><br><span class="line">    .registers 2</span><br><span class="line"></span><br><span class="line">    .line 7</span><br><span class="line">    // 进入synchronized块</span><br><span class="line">    monitor-enter p0</span><br><span class="line"></span><br><span class="line">    .line 8</span><br><span class="line">    // 给v0 寄存器赋值 0x64 也就是十进制的100</span><br><span class="line">    const/16 v0, 0x64</span><br><span class="line"></span><br><span class="line">    :try_start_3</span><br><span class="line">    // p0寄存器是当前对象</span><br><span class="line">    // 将v0中的值移动到p0寄存器中对象的mVal属性中</span><br><span class="line">    iput v0, p0, Lcom/example/application01/ThreadUtils;-&gt;mVal:I</span><br><span class="line"></span><br><span class="line">    .line 9</span><br><span class="line">    // 退出synchronized块</span><br><span class="line">    monitor-exit p0</span><br><span class="line"></span><br><span class="line">    .line 10</span><br><span class="line">    return-void</span><br><span class="line"></span><br><span class="line">    .line 9</span><br><span class="line">    :catchall_7</span><br><span class="line">    move-exception v0</span><br><span class="line"></span><br><span class="line">    // 退出synchronized块</span><br><span class="line">    monitor-exit p0</span><br><span class="line">    :try_end_9</span><br><span class="line">    .catchall &#123;:try_start_3 .. :try_end_9&#125; :catchall_7</span><br><span class="line"></span><br><span class="line">    throw v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ol>
<li>在进入synchronized块的时候会自动生成一条monitor-enter p0指令</li>
<li>退出synchronized块的时候会自动生成一条monitor-exit p0指令</li>
</ol>
<p>因此可以看一下ART虚拟机在执行monitor-enter&#x2F;monitor-exit指令时做了哪些事情来探究一下synchronized块的实现原理。</p>
<h2 id="ART源码分析"><a href="#ART源码分析" class="headerlink" title="ART源码分析"></a>ART源码分析</h2><h3 id="MonitorEnter-加锁"><a href="#MonitorEnter-加锁" class="headerlink" title="MonitorEnter 加锁"></a>MonitorEnter 加锁</h3><p>当ART执行monitor-enter指令时，其最终会调用到Monitor::MonitorEnter函数。</p>
<h4 id="Monitor-MonitorEnter"><a href="#Monitor-MonitorEnter" class="headerlink" title="Monitor::MonitorEnter"></a>Monitor::MonitorEnter</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//获取LockWord</span></span><br><span class="line">    LockWord lock_word = h_obj-&gt;<span class="built_in">GetLockWord</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (lock_word.<span class="built_in">GetState</span>()) &#123;</span><br><span class="line">      <span class="keyword">case</span> LockWord::kUnlocked: &#123;</span><br><span class="line">        <span class="comment">// 如果是未加锁状态，则直接获取锁</span></span><br><span class="line">        <span class="comment">// No ordering required for preceding lockword read, since we retest.</span></span><br><span class="line">        <span class="function">LockWord <span class="title">thin_locked</span><span class="params">(LockWord::FromThinLockId(thread_id, <span class="number">0</span>, lock_word.GCState()))</span></span>;</span><br><span class="line">        <span class="comment">// 方法内部获取到Object内部的monitor变量</span></span><br><span class="line">        <span class="comment">// monitor实际上是一个AtomicInteger* (aka Atomic&lt;uint_32&gt;)</span></span><br><span class="line">        <span class="comment">// 然后调用std::atomic::compare_exchange_strong进行变量读写</span></span><br><span class="line">        <span class="keyword">if</span> (h_obj-&gt;<span class="built_in">CasLockWord</span>(lock_word, thin_locked, CASMode::kWeak, std::memory_order_acquire)) &#123;</span><br><span class="line">        <span class="comment">// 写成功，说明已经拿到锁，直接返回</span></span><br><span class="line">          <span class="built_in">AtraceMonitorLock</span>(self, h_obj.<span class="built_in">Get</span>(), <span class="comment">/* is_wait= */</span> <span class="literal">false</span>);</span><br><span class="line">          <span class="keyword">return</span> h_obj.<span class="built_in">Get</span>();  <span class="comment">// Success!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未成功，再次尝试获取锁</span></span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Go again.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 已经是锁定状态</span></span><br><span class="line">      <span class="keyword">case</span> LockWord::kThinLocked: &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> owner_thread_id = lock_word.<span class="built_in">ThinLockOwner</span>();</span><br><span class="line">        <span class="comment">// 如果是当前线程拥有锁</span></span><br><span class="line">        <span class="keyword">if</span> (owner_thread_id == thread_id) &#123;</span><br><span class="line">          <span class="comment">// No ordering required for initial lockword read.</span></span><br><span class="line">          <span class="comment">// We own the lock, increase the recursion count.</span></span><br><span class="line">          <span class="keyword">uint32_t</span> new_count = lock_word.<span class="built_in">ThinLockCount</span>() + <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 这里进行判断，如果未超过ThinLock的最大值，则不进行锁膨胀</span></span><br><span class="line">          <span class="comment">// 如果已经超过最大值，进行锁膨胀</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(new_count &lt;= LockWord::kThinLockMaxCount)) &#123;</span><br><span class="line">            <span class="function">LockWord <span class="title">thin_locked</span><span class="params">(LockWord::FromThinLockId(thread_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                          new_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                          lock_word.GCState()))</span></span>;</span><br><span class="line">            <span class="comment">// Only this thread pays attention to the count. Thus there is no need for stronger</span></span><br><span class="line">            <span class="comment">// than relaxed memory ordering.</span></span><br><span class="line">            <span class="keyword">if</span> (!kUseReadBarrier) &#123;</span><br><span class="line">              h_obj-&gt;<span class="built_in">SetLockWord</span>(thin_locked, <span class="comment">/* as_volatile= */</span> <span class="literal">false</span>);</span><br><span class="line">              <span class="built_in">AtraceMonitorLock</span>(self, h_obj.<span class="built_in">Get</span>(), <span class="comment">/* is_wait= */</span> <span class="literal">false</span>);</span><br><span class="line">              <span class="keyword">return</span> h_obj.<span class="built_in">Get</span>();  <span class="comment">// Success!</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Use CAS to preserve the read barrier state.</span></span><br><span class="line">              <span class="keyword">if</span> (h_obj-&gt;<span class="built_in">CasLockWord</span>(lock_word,</span><br><span class="line">                                     thin_locked,</span><br><span class="line">                                     CASMode::kWeak,</span><br><span class="line">                                     std::memory_order_relaxed)) &#123;</span><br><span class="line">                <span class="built_in">AtraceMonitorLock</span>(self, h_obj.<span class="built_in">Get</span>(), <span class="comment">/* is_wait= */</span> <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span> h_obj.<span class="built_in">Get</span>();  <span class="comment">// Success!</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// Go again.</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We&#x27;d overflow the recursion count, so inflate the monitor.</span></span><br><span class="line">            <span class="comment">// 超过自旋次数，说明当前线程难以拿到锁，进行锁膨胀</span></span><br><span class="line">            <span class="built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (trylock) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Contention.</span></span><br><span class="line">          contention_count++;</span><br><span class="line">          Runtime* runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line">          <span class="comment">// 判断是否超过最大自旋次数</span></span><br><span class="line">          <span class="keyword">if</span> (contention_count</span><br><span class="line">              &lt;= kExtraSpinIters + runtime-&gt;<span class="built_in">GetMaxSpinsBeforeThinLockInflation</span>()) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Consider switching the thread state to kWaitingForLockInflation when we are</span></span><br><span class="line">            <span class="comment">// yielding.  Use sched_yield instead of NanoSleep since NanoSleep can wait much longer</span></span><br><span class="line">            <span class="comment">// than the parameter you pass in. This can cause thread suspension to take excessively</span></span><br><span class="line">            <span class="comment">// long and make long pauses. See b/16307460.</span></span><br><span class="line">            <span class="keyword">if</span> (contention_count &gt; kExtraSpinIters) &#123;</span><br><span class="line">            <span class="comment">// 尝试简单休眠一下线程，然后再次唤醒进行锁竞争</span></span><br><span class="line">            <span class="comment">// PS: 这是一个System Call，让线程让出CPU，并将线程放到线程调度队列最后</span></span><br><span class="line">              <span class="built_in">sched_yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果超过最大自旋次数，进行锁膨胀</span></span><br><span class="line">            contention_count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// No ordering required for initial lockword read. Install rereads it anyway.</span></span><br><span class="line">            <span class="built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Start from the beginning.</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LockWord::kFatLocked: &#123;</span><br><span class="line">        <span class="comment">// We should have done an acquire read of the lockword initially, to ensure</span></span><br><span class="line">        <span class="comment">// visibility of the monitor data structure. Use an explicit fence instead.</span></span><br><span class="line">        <span class="comment">// 已经是完成了锁膨胀的状态，LockWord已经变成FatWord，LockWorkd的后28bit是MonitorId</span></span><br><span class="line">        std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);</span><br><span class="line">        Monitor* mon = lock_word.<span class="built_in">FatLockMonitor</span>();</span><br><span class="line">        <span class="keyword">if</span> (trylock) &#123;</span><br><span class="line">          <span class="keyword">return</span> mon-&gt;<span class="built_in">TryLock</span>(self) ? h_obj.<span class="built_in">Get</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mon-&gt;<span class="built_in">Lock</span>(self);</span><br><span class="line">          <span class="built_in">DCHECK</span>(mon-&gt;monitor_lock_.<span class="built_in">IsExclusiveHeld</span>(self));</span><br><span class="line">          <span class="keyword">return</span> h_obj.<span class="built_in">Get</span>();  <span class="comment">// Success!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LockWord::kHashCode:</span><br><span class="line">        <span class="comment">// Inflate with the existing hashcode.</span></span><br><span class="line">        <span class="comment">// Again no ordering required for initial lockword read, since we don&#x27;t rely</span></span><br><span class="line">        <span class="comment">// on the visibility of any prior computation.</span></span><br><span class="line">        <span class="built_in">Inflate</span>(self, <span class="literal">nullptr</span>, h_obj.<span class="built_in">Get</span>(), lock_word.<span class="built_in">GetHashCode</span>());</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// Start from the beginning.</span></span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="built_in">GetState</span>();</span><br><span class="line">        <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Monitor-InflateThinLocked"><a href="#Monitor-InflateThinLocked" class="headerlink" title="Monitor::InflateThinLocked"></a>Monitor::InflateThinLocked</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::InflateThinLocked</span><span class="params">(Thread* self, Handle&lt;mirror::Object&gt; obj, LockWord lock_word,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">uint32_t</span> hash_code)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(lock_word.<span class="built_in">GetState</span>(), LockWord::kThinLocked);</span><br><span class="line">  <span class="keyword">uint32_t</span> owner_thread_id = lock_word.<span class="built_in">ThinLockOwner</span>();</span><br><span class="line">  <span class="keyword">if</span> (owner_thread_id == self-&gt;<span class="built_in">GetThreadId</span>()) &#123;</span><br><span class="line">    <span class="comment">// We own the monitor, we can easily inflate it.</span></span><br><span class="line">    <span class="comment">// 如果是当前线程，直接进行锁膨胀</span></span><br><span class="line">    <span class="built_in">Inflate</span>(self, self, obj.<span class="built_in">Get</span>(), hash_code);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ThreadList* thread_list = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetThreadList</span>();</span><br><span class="line">    <span class="comment">// Suspend the owner, inflate. First change to blocked and give up mutator_lock_.</span></span><br><span class="line">    <span class="comment">// 给当前线程的tlsPtr_设置monitor_enter_object</span></span><br><span class="line">    self-&gt;<span class="built_in">SetMonitorEnterObject</span>(obj.<span class="built_in">Get</span>());</span><br><span class="line">    <span class="keyword">bool</span> timed_out;</span><br><span class="line">    Thread* owner;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 自动将当前线程从runable状态切换到suspended状态</span></span><br><span class="line">      <span class="function">ScopedThreadSuspension <span class="title">sts</span><span class="params">(self, ThreadState::kWaitingForLockInflation)</span></span>;</span><br><span class="line">      <span class="comment">// 挂起owner线程</span></span><br><span class="line">      owner = thread_list-&gt;<span class="built_in">SuspendThreadByThreadId</span>(owner_thread_id,</span><br><span class="line">                                                   SuspendReason::kInternal,</span><br><span class="line">                                                   &amp;timed_out);</span><br><span class="line">      <span class="comment">// 此处将当前线程从suspended状态切换回runable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// We succeeded in suspending the thread, check the lock&#x27;s status didn&#x27;t change.</span></span><br><span class="line">      lock_word = obj-&gt;<span class="built_in">GetLockWord</span>(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">if</span> (lock_word.<span class="built_in">GetState</span>() == LockWord::kThinLocked &amp;&amp;</span><br><span class="line">          lock_word.<span class="built_in">ThinLockOwner</span>() == owner_thread_id) &#123;</span><br><span class="line">        <span class="comment">// Go ahead and inflate the lock.</span></span><br><span class="line">        <span class="comment">// 真正在这里执行锁膨胀</span></span><br><span class="line">        <span class="built_in">Inflate</span>(self, owner, obj.<span class="built_in">Get</span>(), hash_code);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 恢复线程执行</span></span><br><span class="line">      <span class="keyword">bool</span> resumed = thread_list-&gt;<span class="built_in">Resume</span>(owner, SuspendReason::kInternal);</span><br><span class="line">      <span class="built_in">DCHECK</span>(resumed);</span><br><span class="line">    &#125;</span><br><span class="line">    self-&gt;<span class="built_in">SetMonitorEnterObject</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monitor-Inflate"><a href="#Monitor-Inflate" class="headerlink" title="Monitor::Inflate"></a>Monitor::Inflate</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::Inflate</span><span class="params">(Thread* self, Thread* owner, ObjPtr&lt;mirror::Object&gt; obj, <span class="keyword">int32_t</span> hash_code)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(self != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">DCHECK</span>(obj != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// Allocate and acquire a new monitor.</span></span><br><span class="line">  <span class="comment">// 在MonitorPool中创建Monitor</span></span><br><span class="line">  Monitor* m = MonitorPool::<span class="built_in">CreateMonitor</span>(self, owner, obj, hash_code);</span><br><span class="line">  <span class="built_in">DCHECK</span>(m != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 在这里面把thinLockWork变成fatLockWord</span></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;<span class="built_in">Install</span>(self)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">VLOG</span>(monitor) &lt;&lt; <span class="string">&quot;monitor: thread&quot;</span> &lt;&lt; owner-&gt;<span class="built_in">GetThreadId</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; created monitor &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; for object &quot;</span> &lt;&lt; obj;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">VLOG</span>(monitor) &lt;&lt; <span class="string">&quot;monitor: Inflate with hashcode &quot;</span> &lt;&lt; hash_code</span><br><span class="line">          &lt;&lt; <span class="string">&quot; created monitor &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; for object &quot;</span> &lt;&lt; obj;</span><br><span class="line">    &#125;</span><br><span class="line">    Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetMonitorList</span>()-&gt;<span class="built_in">Add</span>(m);</span><br><span class="line">    <span class="built_in">CHECK_EQ</span>(obj-&gt;<span class="built_in">GetLockWord</span>(<span class="literal">true</span>).<span class="built_in">GetState</span>(), LockWord::kFatLocked);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MonitorPool::<span class="built_in">ReleaseMonitor</span>(self, m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monitor-Lock"><a href="#Monitor-Lock" class="headerlink" title="Monitor::Lock"></a>Monitor::Lock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::Lock</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> called_monitors_callback = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 尝试spin+cas方式获取futex锁几次，如果能成功获取到，说明竞争不多，可以直接锁定</span></span><br><span class="line">  <span class="comment">// 涉及futex机制</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">TryLock</span>(self, <span class="comment">/*spin=*/</span> <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> This preserves original behavior. Correct?</span></span><br><span class="line">    <span class="keyword">if</span> (called_monitors_callback) &#123;</span><br><span class="line">      <span class="built_in">CHECK</span>(reason == LockReason::kForLock);</span><br><span class="line">      Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetRuntimeCallbacks</span>()-&gt;<span class="built_in">MonitorContendedLocked</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Contended; not reentrant. We hold no locks, so tread carefully.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> log_contention = (lock_profiling_threshold_ != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> wait_start_ms = log_contention ? <span class="built_in">MilliTime</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Thread *orig_owner = <span class="literal">nullptr</span>;</span><br><span class="line">  ArtMethod* owners_method;</span><br><span class="line">  <span class="keyword">uint32_t</span> owners_dex_pc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do this before releasing the mutator lock so that we don&#x27;t get deflated.</span></span><br><span class="line">  <span class="keyword">size_t</span> num_waiters = num_waiters_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> started_trace = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//..... 中间忽略很多代码</span></span><br><span class="line">  <span class="comment">// Call the contended locking cb once and only once. Also only call it if we are locking for</span></span><br><span class="line">  <span class="comment">// the first time, not during a Wait wakeup.</span></span><br><span class="line">  <span class="keyword">if</span> (reason == LockReason::kForLock &amp;&amp; !called_monitors_callback) &#123;</span><br><span class="line">    called_monitors_callback = <span class="literal">true</span>;</span><br><span class="line">    Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetRuntimeCallbacks</span>()-&gt;<span class="built_in">MonitorContendedLocking</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;<span class="built_in">SetMonitorEnterObject</span>(<span class="built_in">GetObject</span>().<span class="built_in">Ptr</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Change to blocked and give up mutator_lock_.</span></span><br><span class="line">    <span class="function">ScopedThreadSuspension <span class="title">tsc</span><span class="params">(self, ThreadState::kBlocked)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire monitor_lock_ without mutator_lock_, expecting to block this time.</span></span><br><span class="line">    <span class="comment">// We already tried spinning above. The shutdown procedure currently assumes we stop</span></span><br><span class="line">    <span class="comment">// touching monitors shortly after we suspend, so don&#x27;t spin again here.</span></span><br><span class="line">    monitor_lock_.<span class="built_in">ExclusiveLock</span>(self);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We&#x27;ve successfully acquired monitor_lock_, released thread_list_lock, and are runnable.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We avoided touching monitor fields while suspended, so set owner_ here.</span></span><br><span class="line">  owner_.<span class="built_in">store</span>(self, std::memory_order_relaxed);</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(lock_count_, <span class="number">0u</span>);</span><br><span class="line">  </span><br><span class="line">  self-&gt;<span class="built_in">SetMonitorEnterObject</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  num_waiters_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  <span class="built_in">DCHECK</span>(monitor_lock_.<span class="built_in">IsExclusiveHeld</span>(self));</span><br><span class="line">  <span class="comment">// We need to pair this with a single contended locking call. NB we match the RI behavior and call</span></span><br><span class="line">  <span class="comment">// this even if MonitorEnter failed.</span></span><br><span class="line">  <span class="keyword">if</span> (called_monitors_callback) &#123;</span><br><span class="line">    <span class="built_in">CHECK</span>(reason == LockReason::kForLock);</span><br><span class="line">    Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetRuntimeCallbacks</span>()-&gt;<span class="built_in">MonitorContendedLocked</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monitor-TryLock"><a href="#Monitor-TryLock" class="headerlink" title="Monitor::TryLock"></a>Monitor::TryLock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Monitor::TryLock</span><span class="params">(Thread* self, <span class="keyword">bool</span> spin)</span> </span>&#123;</span><br><span class="line">  Thread *owner = owner_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (owner == self) &#123;</span><br><span class="line">    <span class="comment">// 如果当前线程是monitor的owner，直接返回就好，不需要再尝试获取锁</span></span><br><span class="line">    lock_count_++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据是否spin尝试不同的获取锁的方式</span></span><br><span class="line">    <span class="keyword">bool</span> success = spin ? monitor_lock_.<span class="built_in">ExclusiveTryLockWithSpinning</span>(self)</span><br><span class="line">        : monitor_lock_.<span class="built_in">ExclusiveTryLock</span>(self);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新owner</span></span><br><span class="line">    owner_.<span class="built_in">store</span>(self, std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutex-ExclusiveTryLock"><a href="#Mutex-ExclusiveTryLock" class="headerlink" title="Mutex::ExclusiveTryLock"></a>Mutex::ExclusiveTryLock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Mutex::ExclusiveTryLock</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">if</span> (!recursive_ || !<span class="built_in">IsExclusiveHeld</span>(self)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ART_USE_FUTEXES</span></span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int32_t</span> cur_state = state_and_contenders_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">if</span> ((cur_state &amp; kHeldMask) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有人持有锁，这里竞争者应该会比较少，尝试使用CAS方式获取锁，效率会比较高</span></span><br><span class="line">        <span class="comment">// Change state to held and impose load/store ordering appropriate for lock acquisition.</span></span><br><span class="line">        done = state_and_contenders_.<span class="built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经有人获取了锁，直接返回好了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!done);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">pthread_mutex_trylock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">if</span> (result == EBUSY) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">      errno = result;</span><br><span class="line">      <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;pthread_mutex_trylock failed for &quot;</span> &lt;&lt; name_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">    exclusive_owner_.<span class="built_in">store</span>(<span class="built_in">SafeGetTid</span>(self), std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">RegisterAsLocked</span>(self);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutex-ExclusiveTryLockWithSpinning"><a href="#Mutex-ExclusiveTryLockWithSpinning" class="headerlink" title="Mutex::ExclusiveTryLockWithSpinning"></a>Mutex::ExclusiveTryLockWithSpinning</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Mutex::ExclusiveTryLockWithSpinning</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Spin a small number of times, since this affects our ability to respond to suspension</span></span><br><span class="line">  <span class="comment">// requests. We spin repeatedly only if the mutex repeatedly becomes available and unavailable</span></span><br><span class="line">  <span class="comment">// in rapid succession, and then we will typically not spin for the maximal period.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> kMaxSpins = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kMaxSpins; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ExclusiveTryLock</span>(self)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ART_USE_FUTEXES</span></span><br><span class="line">    <span class="comment">// WaitBrieflyFor内部会进行自旋，如果这里自旋依然无法持有锁，说明竞争条件比较多</span></span><br><span class="line">    <span class="comment">// 没必要继续自旋下去，直接尝试后面的futex系统调用，休眠线程</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self,</span><br><span class="line">            [](<span class="keyword">int32_t</span> v) &#123; <span class="built_in"><span class="keyword">return</span></span> (v &amp; kHeldMask) == <span class="number">0</span>; &#125;)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ExclusiveTryLock</span>(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutex-ExclusiveLock"><a href="#Mutex-ExclusiveLock" class="headerlink" title="Mutex::ExclusiveLock"></a>Mutex::ExclusiveLock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mutex::ExclusiveLock</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!recursive_ || !<span class="built_in">IsExclusiveHeld</span>(self)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ART_USE_FUTEXES</span></span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int32_t</span> cur_state = state_and_contenders_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">          <span class="comment">// 说明没有人持有锁，尝试CAS方式获取，如果获取到，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">LIKELY</span>((cur_state &amp; kHeldMask) == <span class="number">0</span>) <span class="comment">/* lock not held */</span>) &#123;</span><br><span class="line">        done = state_and_contenders_.<span class="built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Failed to acquire, hang up.</span></span><br><span class="line">        ScopedContentionRecorder <span class="built_in">scr</span>(<span class="keyword">this</span>, <span class="built_in">SafeGetTid</span>(self), <span class="built_in">GetExclusiveOwnerTid</span>());</span><br><span class="line">        <span class="comment">// Empirically, it appears important to spin again each time through the loop; if we</span></span><br><span class="line">        <span class="comment">// bother to go to sleep and wake up, we should be fairly persistent in trying for the</span></span><br><span class="line">        <span class="comment">// lock.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self,</span><br><span class="line">                            [](<span class="keyword">int32_t</span> v) &#123; <span class="built_in"><span class="keyword">return</span></span> (v &amp; kHeldMask) == <span class="number">0</span>; &#125;)) &#123;</span><br><span class="line">                  <span class="comment">// 进入到这里面说明是自选了一段时间以后依然没有得到锁</span></span><br><span class="line">          <span class="comment">// Increment contender count. We can not create enough threads for this to overflow.</span></span><br><span class="line">                  <span class="comment">// 原子性的state_and_contenders_ + 1</span></span><br><span class="line">          <span class="built_in">increment_contenders</span>();</span><br><span class="line">          <span class="comment">// Make cur_state again reflect the expected value of state_and_contenders.</span></span><br><span class="line">          cur_state += kContenderIncrement;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(should_respond_to_empty_checkpoint_request_)) &#123;</span><br><span class="line">            self-&gt;<span class="built_in">CheckEmptyCheckpointFromMutex</span>();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">uint64_t</span> wait_start_ms = enable_monitor_timeout_ ? <span class="built_in">MilliTime</span>() : <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">uint64_t</span> try_times = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            timespec timeout_ts;</span><br><span class="line">            timeout_ts.tv_sec = <span class="number">0</span>;</span><br><span class="line">            timeout_ts.tv_nsec = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetMonitorTimeoutNs</span>();</span><br><span class="line">                        <span class="comment">// 这里的逻辑是，如果state_and_contenders_跟cur_state相等，则挂起线程，直到有其他线程wakeup或超时</span></span><br><span class="line">                        <span class="comment">// 根据上面的逻辑，如果有人持有锁，才会走到这里，因此cur_state的held_mask标记位是有人持有锁，所以state_and_contenders_跟cur_state相等</span></span><br><span class="line">                        <span class="comment">// 表示现在是有人再持有锁的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">futex</span>(state_and_contenders_.<span class="built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_state,</span><br><span class="line">                      enable_monitor_timeout_ ? &amp;timeout_ts : <span class="literal">nullptr</span> , <span class="literal">nullptr</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// We only went to sleep after incrementing and contenders and checking that the</span></span><br><span class="line">              <span class="comment">// lock is still held by someone else.  EAGAIN and EINTR both indicate a spurious</span></span><br><span class="line">              <span class="comment">// failure, try again from the beginning.  We do not use TEMP_FAILURE_RETRY so we can</span></span><br><span class="line">              <span class="comment">// intentionally retry to acquire the lock.</span></span><br><span class="line">                          <span class="comment">// ........</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">SleepIfRuntimeDeleted</span>(self);</span><br><span class="line">            <span class="comment">// Retry until not held. In heavy contention situations we otherwise get redundant</span></span><br><span class="line">            <span class="comment">// futex wakeups as a result of repeatedly decrementing and incrementing contenders.</span></span><br><span class="line">            cur_state = state_and_contenders_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">          &#125; <span class="keyword">while</span> ((cur_state &amp; kHeldMask) != <span class="number">0</span>);</span><br><span class="line">          <span class="built_in">decrement_contenders</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!done);</span><br><span class="line">    <span class="comment">// Confirm that lock is now held.</span></span><br><span class="line">    <span class="built_in">DCHECK_NE</span>(state_and_contenders_.<span class="built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// 如果不支持futex，这里使用pthread_mutex进行实现，不做具体分析了</span></span><br><span class="line">    <span class="built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_lock, (&amp;mutex_));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">    exclusive_owner_.<span class="built_in">store</span>(<span class="built_in">SafeGetTid</span>(self), std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">RegisterAsLocked</span>(self);</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">  &#125;</span><br><span class="line">  recursion_count_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MonitorExit-释放锁"><a href="#MonitorExit-释放锁" class="headerlink" title="MonitorExit 释放锁"></a>MonitorExit 释放锁</h3><p>ART虚拟机在执行到monitor-exit的时候，最终会执行到Monitor::MonitorExit函数。</p>
<h4 id="Monitor-MonitorExit"><a href="#Monitor-MonitorExit" class="headerlink" title="Monitor::MonitorExit"></a>Monitor::MonitorExit</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Monitor::MonitorExit</span><span class="params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(self)</span></span>;</span><br><span class="line">  <span class="function">Handle&lt;mirror::Object&gt; <span class="title">h_obj</span><span class="params">(hs.NewHandle(obj))</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    LockWord lock_word = obj-&gt;<span class="built_in">GetLockWord</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (lock_word.<span class="built_in">GetState</span>()) &#123;</span><br><span class="line">      <span class="keyword">case</span> LockWord::kHashCode:</span><br><span class="line">        <span class="comment">// Fall-through.</span></span><br><span class="line">      <span class="keyword">case</span> LockWord::kUnlocked:</span><br><span class="line">        <span class="comment">// 在这里面抛出异常</span></span><br><span class="line">        <span class="built_in">FailedUnlock</span>(h_obj.<span class="built_in">Get</span>(), self-&gt;<span class="built_in">GetThreadId</span>(), <span class="number">0u</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// Failure.</span></span><br><span class="line">      <span class="keyword">case</span> LockWord::kThinLocked: &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> thread_id = self-&gt;<span class="built_in">GetThreadId</span>();</span><br><span class="line">        <span class="keyword">uint32_t</span> owner_thread_id = lock_word.<span class="built_in">ThinLockOwner</span>();</span><br><span class="line">        <span class="keyword">if</span> (owner_thread_id != thread_id) &#123;</span><br><span class="line">          <span class="comment">// 抛出异常</span></span><br><span class="line">          <span class="built_in">FailedUnlock</span>(h_obj.<span class="built_in">Get</span>(), thread_id, owner_thread_id, <span class="literal">nullptr</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// Failure.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We own the lock, decrease the recursion count.</span></span><br><span class="line">          <span class="comment">// 如果LockWord中的recusion count 不为0，递减</span></span><br><span class="line">          <span class="comment">// 如果已经是0， 直接重置LockWord，变为无锁状态的</span></span><br><span class="line">          LockWord new_lw = LockWord::<span class="built_in">Default</span>();</span><br><span class="line">          <span class="keyword">if</span> (lock_word.<span class="built_in">ThinLockCount</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> new_count = lock_word.<span class="built_in">ThinLockCount</span>() - <span class="number">1</span>;</span><br><span class="line">            new_lw = LockWord::<span class="built_in">FromThinLockId</span>(thread_id, new_count, lock_word.<span class="built_in">GCState</span>());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            new_lw = LockWord::<span class="built_in">FromDefault</span>(lock_word.<span class="built_in">GCState</span>());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!kUseReadBarrier) &#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> This really only needs memory_order_release, but we currently have</span></span><br><span class="line">            <span class="comment">// no way to specify that. In fact there seem to be no legitimate uses of SetLockWord</span></span><br><span class="line">            <span class="comment">// with a final argument of true. This slows down x86 and ARMv7, but probably not v8.</span></span><br><span class="line">            h_obj-&gt;<span class="built_in">SetLockWord</span>(new_lw, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">AtraceMonitorUnlock</span>();</span><br><span class="line">            <span class="comment">// Success!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Use CAS to preserve the read barrier state.</span></span><br><span class="line">            <span class="keyword">if</span> (h_obj-&gt;<span class="built_in">CasLockWord</span>(lock_word, new_lw, CASMode::kWeak, std::memory_order_release)) &#123;</span><br><span class="line">              <span class="built_in">AtraceMonitorUnlock</span>();</span><br><span class="line">              <span class="comment">// Success!</span></span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;  <span class="comment">// Go again.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LockWord::kFatLocked: &#123;</span><br><span class="line">        <span class="comment">// 已经是Fat LockWord，走Monitor的unlock逻辑，见2.2.2</span></span><br><span class="line">        Monitor* mon = lock_word.<span class="built_in">FatLockMonitor</span>();</span><br><span class="line">        <span class="keyword">return</span> mon-&gt;<span class="built_in">Unlock</span>(self);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monitor-Unlock"><a href="#Monitor-Unlock" class="headerlink" title="Monitor::Unlock"></a>Monitor::Unlock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Monitor::Unlock</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Thread* owner = owner_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (owner == self) &#123;</span><br><span class="line">    <span class="comment">// We own the monitor, so nobody else can be in here.</span></span><br><span class="line">    <span class="built_in">CheckLockOwnerRequest</span>(self);</span><br><span class="line">    <span class="built_in">AtraceMonitorUnlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (lock_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">      owner_.<span class="built_in">store</span>(<span class="literal">nullptr</span>, std::memory_order_relaxed);</span><br><span class="line">      <span class="comment">// 解锁并唤醒其他调用了Object.wait()正在等待的线程，见2.2.3</span></span><br><span class="line">      <span class="built_in">SignalWaiterAndReleaseMonitorLock</span>(self);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      --lock_count_;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">// Keep monitor_lock_, but pretend we released it.</span></span><br><span class="line">      <span class="built_in">FakeUnlockMonitorLock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面是解锁失败，抛出异常</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monitor-SignalWaiterAndReleaseMonitorLock"><a href="#Monitor-SignalWaiterAndReleaseMonitorLock" class="headerlink" title="Monitor::SignalWaiterAndReleaseMonitorLock"></a>Monitor::SignalWaiterAndReleaseMonitorLock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We want to release the monitor and signal up to one thread that was waiting</span></span><br><span class="line">  <span class="comment">// but has since been notified.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (wake_set_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No risk of waking ourselves here; since monitor_lock_ is not released until we&#x27;re ready to</span></span><br><span class="line">    <span class="comment">// return, notify can&#x27;t move the current thread from wait_set_ to wake_set_ until this</span></span><br><span class="line">    <span class="comment">// method is done checking wake_set_.</span></span><br><span class="line">    <span class="comment">// 获取wake_set_中第一个元素</span></span><br><span class="line">    <span class="comment">// wake_set_在Object.notify()或Object.notifyAll()中被设置</span></span><br><span class="line">    Thread* thread = wake_set_;</span><br><span class="line">    wake_set_ = thread-&gt;<span class="built_in">GetWaitNext</span>();</span><br><span class="line">    thread-&gt;<span class="built_in">SetWaitNext</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Check to see if the thread is still waiting.</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">MutexLock <span class="title">wait_mu</span><span class="params">(self, *thread-&gt;GetWaitMutex())</span></span>;</span><br><span class="line">      <span class="comment">// wait_monitor_在Object.wait()时候被设置</span></span><br><span class="line">      <span class="keyword">if</span> (thread-&gt;<span class="built_in">GetWaitMonitor</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 此时说明该线程依然在等待，当前线程释放锁并唤醒对应线程</span></span><br><span class="line">        <span class="comment">// Release the lock, so that a potentially awakened thread will not</span></span><br><span class="line">        <span class="comment">// immediately contend on it. The lock ordering here is:</span></span><br><span class="line">        <span class="comment">// monitor_lock_, self-&gt;GetWaitMutex, thread-&gt;GetWaitMutex</span></span><br><span class="line">        <span class="comment">// 释放锁，见2.2.4</span></span><br><span class="line">        monitor_lock_.<span class="built_in">Unlock</span>(self);  <span class="comment">// Releases contenders.</span></span><br><span class="line">        <span class="comment">// 在这里唤醒正在等待中的线程</span></span><br><span class="line">        <span class="comment">// 这里执行完毕后，被唤醒的线程会重新尝试调用Monitor::Lock()获取锁</span></span><br><span class="line">        <span class="comment">// 见2.3.5</span></span><br><span class="line">        thread-&gt;<span class="built_in">GetWaitConditionVariable</span>()-&gt;<span class="built_in">Signal</span>(self);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  monitor_lock_.<span class="built_in">Unlock</span>(self);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!monitor_lock_.<span class="built_in">IsExclusiveHeld</span>(self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mutex-Unlock"><a href="#Mutex-Unlock" class="headerlink" title="Mutex::Unlock"></a>Mutex::Unlock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unlock</span><span class="params">(Thread* self)</span> <span class="title">RELEASE</span><span class="params">()</span> </span>&#123;  <span class="built_in">ExclusiveUnlock</span>(self); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mutex::ExclusiveUnlock</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  recursion_count_--;</span><br><span class="line">  <span class="keyword">if</span> (!recursive_ || recursion_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">RegisterAsUnlocked</span>(self);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ART_USE_FUTEXES</span></span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">int32_t</span> cur_state = state_and_contenders_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">LIKELY</span>((cur_state &amp; kHeldMask) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re no longer the owner.</span></span><br><span class="line">        exclusive_owner_.<span class="built_in">store</span>(<span class="number">0</span> <span class="comment">/* pid */</span>, std::memory_order_relaxed);</span><br><span class="line">        <span class="comment">// Change state to not held and impose load/store ordering appropriate for lock release.</span></span><br><span class="line">        <span class="comment">// 重新设置state，标记为无持有者</span></span><br><span class="line">        <span class="keyword">uint32_t</span> new_state = cur_state &amp; ~kHeldMask;  <span class="comment">// Same number of contenders.</span></span><br><span class="line">        <span class="comment">// CAS方式设置state</span></span><br><span class="line">        done = state_and_contenders_.<span class="built_in">CompareAndSetWeakRelease</span>(cur_state, new_state);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(done)) &#123;  <span class="comment">// Spurious fail or waiters changed ?</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_state != <span class="number">0</span>) <span class="comment">/* have contenders */</span>) &#123;</span><br><span class="line">            <span class="comment">// 依然存在竞争线程</span></span><br><span class="line">            <span class="comment">// 唤醒kWakeOne个在state_and_contenders_.Address()上等待的线程</span></span><br><span class="line">            <span class="built_in">futex</span>(state_and_contenders_.<span class="built_in">Address</span>(), FUTEX_WAKE_PRIVATE, kWakeOne,</span><br><span class="line">                  <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="comment">// 没有走进上面的if说明当前锁没有竞争线程，</span></span><br><span class="line">          <span class="comment">// CAS方式更改state_and_contenders_计数器已经足够，不需要唤醒其他线程</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!done);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    exclusive_owner_.<span class="built_in">store</span>(<span class="number">0</span> <span class="comment">/* pid */</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_unlock, (&amp;mutex_));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><p>Object.wait()方法也是经常在synchronized块中用到的方法。<br>点击代码进去查看源码时可以看到它最终是一个native方法。</p>
<h4 id="Object-wait-Java"><a href="#Object-wait-Java" class="headerlink" title="Object.wait() [Java]"></a>Object.wait() [Java]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(timeout, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="comment">// 发现是一个native方法，具体实现见2.3.2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Object-waitWaitJI"><a href="#Object-waitWaitJI" class="headerlink" title="Object_waitWaitJI()"></a>Object_waitWaitJI()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Object_waitJI</span><span class="params">(JNIEnv* env, jobject java_this, jlong ms, jint ns)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  soa.Decode&lt;mirror::Object&gt;(java_this)-&gt;<span class="built_in">Wait</span>(soa.<span class="built_in">Self</span>(), ms, ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="art-mirror-Object-Wait"><a href="#art-mirror-Object-Wait" class="headerlink" title="art::mirror::Object::Wait"></a>art::mirror::Object::Wait</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Object::Wait</span><span class="params">(Thread* self, <span class="keyword">int64_t</span> ms, <span class="keyword">int32_t</span> ns)</span> </span>&#123;</span><br><span class="line">  Monitor::<span class="built_in">Wait</span>(self, <span class="keyword">this</span>, ms, ns, <span class="literal">true</span>, ThreadState::kTimedWaiting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="static-Monitor-Wait"><a href="#static-Monitor-Wait" class="headerlink" title="static Monitor::Wait"></a>static Monitor::Wait</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::Wait</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                   ObjPtr&lt;mirror::Object&gt; obj,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">int64_t</span> ms,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">int32_t</span> ns,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">bool</span> interruptShouldThrow,</span></span></span><br><span class="line"><span class="params"><span class="function">                   ThreadState why)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(self)</span></span>;</span><br><span class="line">  <span class="function">Handle&lt;mirror::Object&gt; <span class="title">h_obj</span><span class="params">(hs.NewHandle(obj))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  LockWord lock_word = h_obj-&gt;<span class="built_in">GetLockWord</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 如果已经是Fat LockWord，不用再走所膨胀流程，直接走后面的Monitor::Wait</span></span><br><span class="line">  <span class="keyword">while</span> (lock_word.<span class="built_in">GetState</span>() != LockWord::kFatLocked) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (lock_word.<span class="built_in">GetState</span>()) &#123;</span><br><span class="line">      <span class="keyword">case</span> LockWord::kHashCode:</span><br><span class="line">        <span class="comment">// Fall-through.</span></span><br><span class="line">      <span class="keyword">case</span> LockWord::kUnlocked:</span><br><span class="line">        <span class="built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="string">&quot;object not locked by thread before wait()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// Failure.</span></span><br><span class="line">      <span class="keyword">case</span> LockWord::kThinLocked: &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> thread_id = self-&gt;<span class="built_in">GetThreadId</span>();</span><br><span class="line">        <span class="keyword">uint32_t</span> owner_thread_id = lock_word.<span class="built_in">ThinLockOwner</span>();</span><br><span class="line">        <span class="comment">// 只能在当前持有锁的线程调用wait()，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (owner_thread_id != thread_id) &#123;</span><br><span class="line">          <span class="built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="string">&quot;object not locked by thread before wait()&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;  <span class="comment">// Failure.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We own the lock, inflate to enqueue ourself on the Monitor. May fail spuriously so</span></span><br><span class="line">          <span class="comment">// re-load.</span></span><br><span class="line">          <span class="comment">// 进行锁膨胀</span></span><br><span class="line">          <span class="built_in">Inflate</span>(self, self, h_obj.<span class="built_in">Get</span>(), <span class="number">0</span>);</span><br><span class="line">          lock_word = h_obj-&gt;<span class="built_in">GetLockWord</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LockWord::kFatLocked:  <span class="comment">// Unreachable given the loop condition above. Fall-through.</span></span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="comment">// LOG(FATAL) &lt;&lt; &quot;Invalid monitor state &quot; &lt;&lt; lock_word.GetState();</span></span><br><span class="line">        <span class="comment">// UNREACHABLE();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Monitor* mon = lock_word.<span class="built_in">FatLockMonitor</span>();</span><br><span class="line">  <span class="comment">// 真正执行wait的地方，见2.3.5</span></span><br><span class="line">  mon-&gt;<span class="built_in">Wait</span>(self, ms, ns, interruptShouldThrow, why);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monitor-Wait"><a href="#Monitor-Wait" class="headerlink" title="Monitor::Wait"></a>Monitor::Wait</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::Wait</span><span class="params">(Thread* self, <span class="keyword">int64_t</span> ms, <span class="keyword">int32_t</span> ns,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">bool</span> interruptShouldThrow, ThreadState why)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// We need to turn a zero-length timed wait into a regular wait because</span></span><br><span class="line">  <span class="comment">// Object.wait(0, 0) is defined as Object.wait(0), which is defined as Object.wait().</span></span><br><span class="line">  <span class="keyword">if</span> (why == ThreadState::kTimedWaiting &amp;&amp; (ms == <span class="number">0</span> &amp;&amp; ns == <span class="number">0</span>)) &#123;</span><br><span class="line">    why = ThreadState::kWaiting;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Release our hold - we need to let it go even if we&#x27;re a few levels</span></span><br><span class="line"><span class="comment">   * deep in a recursive lock, and we need to restore that later.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> prev_lock_count = lock_count_;</span><br><span class="line">  lock_count_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> was_interrupted = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> timed_out = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// Update monitor state now; it&#x27;s not safe once we&#x27;re &quot;suspended&quot;.</span></span><br><span class="line">  owner_.<span class="built_in">store</span>(<span class="literal">nullptr</span>, std::memory_order_relaxed);</span><br><span class="line">  num_waiters_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Update thread state. If the GC wakes up, it&#x27;ll ignore us, knowing</span></span><br><span class="line">    <span class="comment">// that we won&#x27;t touch any references in this state, and we&#x27;ll check</span></span><br><span class="line">    <span class="comment">// our suspend mode before we transition out.</span></span><br><span class="line">    <span class="function">ScopedThreadSuspension <span class="title">sts</span><span class="params">(self, why)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pseudo-atomically wait on self&#x27;s wait_cond_ and release the monitor lock.</span></span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *self-&gt;GetWaitMutex())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Add ourselves to the set of threads waiting on this monitor.</span></span><br><span class="line"><span class="comment">     * It&#x27;s important that we are only added to the wait set after</span></span><br><span class="line"><span class="comment">     * acquiring our GetWaitMutex, so that calls to Notify() that occur after we</span></span><br><span class="line"><span class="comment">     * have released monitor_lock_ will not move us from wait_set_ to wake_set_</span></span><br><span class="line"><span class="comment">     * until we&#x27;ve signalled contenders on this monitor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 把自己加入wait_set_最后</span></span><br><span class="line">    <span class="comment">// wait_set_是一个链表</span></span><br><span class="line">    <span class="built_in">AppendToWaitSet</span>(self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set wait_monitor_ to the monitor object we will be waiting on. When wait_monitor_ is</span></span><br><span class="line">    <span class="comment">// non-null a notifying or interrupting thread must signal the thread&#x27;s wait_cond_ to wake it</span></span><br><span class="line">    <span class="comment">// up.</span></span><br><span class="line">    <span class="built_in">DCHECK</span>(self-&gt;<span class="built_in">GetWaitMonitor</span>() == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// wait_monitor_置空</span></span><br><span class="line">    self-&gt;<span class="built_in">SetWaitMonitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the monitor lock.</span></span><br><span class="line">    <span class="built_in">DCHECK</span>(monitor_lock_.<span class="built_in">IsExclusiveHeld</span>(self));</span><br><span class="line">    <span class="comment">// 见2.2.3</span></span><br><span class="line">    <span class="built_in">SignalWaiterAndReleaseMonitorLock</span>(self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the case where the thread was interrupted before we called wait().</span></span><br><span class="line">    <span class="keyword">if</span> (self-&gt;<span class="built_in">IsInterrupted</span>()) &#123;</span><br><span class="line">      was_interrupted = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Wait for a notification or a timeout to occur.</span></span><br><span class="line">      <span class="keyword">if</span> (why == ThreadState::kWaiting) &#123;</span><br><span class="line">        self-&gt;<span class="built_in">GetWaitConditionVariable</span>()-&gt;<span class="built_in">Wait</span>(self);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DCHECK</span>(why == ThreadState::kTimedWaiting || why == ThreadState::kSleeping) &lt;&lt; why;</span><br><span class="line">        timed_out = self-&gt;<span class="built_in">GetWaitConditionVariable</span>()-&gt;<span class="built_in">TimedWait</span>(self, ms, ns);</span><br><span class="line">      &#125;</span><br><span class="line">      was_interrupted = self-&gt;<span class="built_in">IsInterrupted</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// We reset the thread&#x27;s wait_monitor_ field after transitioning back to runnable so</span></span><br><span class="line">    <span class="comment">// that a thread in a waiting/sleeping state has a non-null wait_monitor_ for debugging</span></span><br><span class="line">    <span class="comment">// and diagnostic purposes. (If you reset this earlier, stack dumps will claim that threads</span></span><br><span class="line">    <span class="comment">// are waiting on &quot;null&quot;.)</span></span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *self-&gt;GetWaitMutex())</span></span>;</span><br><span class="line">    <span class="built_in">DCHECK</span>(self-&gt;<span class="built_in">GetWaitMonitor</span>() != <span class="literal">nullptr</span>);</span><br><span class="line">    self-&gt;<span class="built_in">SetWaitMonitor</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// end wait</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We just slept, tell the runtime callbacks about this.</span></span><br><span class="line">  Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetRuntimeCallbacks</span>()-&gt;<span class="built_in">MonitorWaitFinished</span>(<span class="keyword">this</span>, timed_out);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-acquire the monitor and lock.</span></span><br><span class="line">  <span class="comment">// 重新获取锁，在调用self-&gt;GetWaitConditionVariable()-&gt;notify()之前需要先Unlock</span></span><br><span class="line">  <span class="comment">// 见2.2.3 </span></span><br><span class="line">  Lock&lt;LockReason::kForWait&gt;(self);</span><br><span class="line">  lock_count_ = prev_lock_count;</span><br><span class="line">  <span class="built_in">DCHECK</span>(monitor_lock_.<span class="built_in">IsExclusiveHeld</span>(self));</span><br><span class="line">  self-&gt;<span class="built_in">GetWaitMutex</span>()-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line"></span><br><span class="line">  num_waiters_.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">  <span class="built_in">RemoveFromWaitSet</span>(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Notify"><a href="#Notify" class="headerlink" title="Notify"></a>Notify</h3><h4 id="Object-notify-java"><a href="#Object-notify-java" class="headerlink" title="Object.notify() [java]"></a>Object.notify() [java]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="comment">// native方法，实现见2.4.2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="Object-notify"><a href="#Object-notify" class="headerlink" title="Object_notify"></a>Object_notify</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Object_notify</span><span class="params">(JNIEnv* env, jobject java_this)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  soa.Decode&lt;mirror::Object&gt;(java_this)-&gt;<span class="built_in">Notify</span>(soa.<span class="built_in">Self</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="art-mirror-Object-Notify"><a href="#art-mirror-Object-Notify" class="headerlink" title="art::mirror::Object::Notify"></a>art::mirror::Object::Notify</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Object::Notify</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  Monitor::<span class="built_in">Notify</span>(self, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="static-Monitor-Notify"><a href="#static-Monitor-Notify" class="headerlink" title="static Monitor::Notify"></a>static Monitor::Notify</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span></span></span><br><span class="line"><span class="function">     <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">DoNotify</span>(self, obj, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h5 id="Monitor-DoNotify"><a href="#Monitor-DoNotify" class="headerlink" title="Monitor::DoNotify"></a>Monitor::DoNotify</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::DoNotify</span><span class="params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="keyword">bool</span> notify_all)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  LockWord lock_word = obj-&gt;<span class="built_in">GetLockWord</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (lock_word.<span class="built_in">GetState</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> LockWord::kHashCode:</span><br><span class="line">      <span class="comment">// Fall-through.</span></span><br><span class="line">    <span class="keyword">case</span> LockWord::kUnlocked:</span><br><span class="line">      <span class="built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="string">&quot;object not locked by thread before notify()&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">// Failure.</span></span><br><span class="line">    <span class="keyword">case</span> LockWord::kThinLocked: &#123;</span><br><span class="line">      <span class="keyword">uint32_t</span> thread_id = self-&gt;<span class="built_in">GetThreadId</span>();</span><br><span class="line">      <span class="keyword">uint32_t</span> owner_thread_id = lock_word.<span class="built_in">ThinLockOwner</span>();</span><br><span class="line">      <span class="keyword">if</span> (owner_thread_id != thread_id) &#123;</span><br><span class="line">        <span class="built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="string">&quot;object not locked by thread before notify()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// Failure.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We own the lock but there&#x27;s no Monitor and therefore no waiters.</span></span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// Success.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> LockWord::kFatLocked: &#123;</span><br><span class="line">      <span class="comment">// 必须已经是Fat LockWord才可以，其他状态都抛异常</span></span><br><span class="line">      Monitor* mon = lock_word.<span class="built_in">FatLockMonitor</span>();</span><br><span class="line">      <span class="keyword">if</span> (notify_all) &#123;</span><br><span class="line">        mon-&gt;<span class="built_in">NotifyAll</span>(self);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mon-&gt;<span class="built_in">Notify</span>(self);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">// Success.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="built_in">GetState</span>();</span><br><span class="line">      <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Monitor-Notify"><a href="#Monitor-Notify" class="headerlink" title="Monitor::Notify"></a>Monitor::Notify</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::Notify</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把wait_set_中的第一个放到wake_set_中</span></span><br><span class="line">  <span class="comment">// wait_set_构建见2.3.5</span></span><br><span class="line">  <span class="comment">// 这里指示移动元素，并不会释放锁并唤起等待的线程</span></span><br><span class="line">  <span class="comment">// 释放锁和唤起等待线程是在wait()或Monitor::MonitorExit的时候，分别见3.5和2.3</span></span><br><span class="line">  Thread* to_move = wait_set_;</span><br><span class="line">  <span class="keyword">if</span> (to_move != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    wait_set_ = to_move-&gt;<span class="built_in">GetWaitNext</span>();</span><br><span class="line">    to_move-&gt;<span class="built_in">SetWaitNext</span>(wake_set_);</span><br><span class="line">    wake_set_ = to_move;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-notifyAll-java"><a href="#Object-notifyAll-java" class="headerlink" title="Object.notifyAll() [java]"></a>Object.notifyAll() [java]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="Object-notifyAll"><a href="#Object-notifyAll" class="headerlink" title="Object_notifyAll"></a>Object_notifyAll</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Object_notifyAll</span><span class="params">(JNIEnv* env, jobject java_this)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  soa.Decode&lt;mirror::Object&gt;(java_this)-&gt;<span class="built_in">NotifyAll</span>(soa.<span class="built_in">Self</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="art-mirror-Object-NotifyAll"><a href="#art-mirror-Object-NotifyAll" class="headerlink" title="art::mirror::Object::NotifyAll"></a>art::mirror::Object::NotifyAll</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Object::NotifyAll</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  Monitor::<span class="built_in">NotifyAll</span>(self, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="static-Monitor-NotifyAll"><a href="#static-Monitor-NotifyAll" class="headerlink" title="static Monitor::NotifyAll"></a>static Monitor::NotifyAll</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span></span></span><br><span class="line"><span class="function">     <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">DoNotify</span>(self, obj, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Monitor-NotifyAll"><a href="#Monitor-NotifyAll" class="headerlink" title="Monitor::NotifyAll"></a>Monitor::NotifyAll</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Monitor::NotifyAll</span><span class="params">(Thread* self)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把wait_set_中的所有元素移动到wake_set_中</span></span><br><span class="line">  <span class="comment">// wait_set_构建见2.3.5</span></span><br><span class="line">  <span class="comment">// 这里指示移动元素，并不会释放锁并唤起等待的线程</span></span><br><span class="line">  <span class="comment">// 释放锁和唤起等待线程是在wait()或Monitor::MonitorExit的时候，分别见3.5和2.3</span></span><br><span class="line">  Thread* to_move = wait_set_;</span><br><span class="line">  <span class="keyword">if</span> (to_move != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    wait_set_ = <span class="literal">nullptr</span>;</span><br><span class="line">    Thread* move_to = wake_set_;</span><br><span class="line">    <span class="keyword">if</span> (move_to == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      wake_set_ = to_move;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (move_to-&gt;<span class="built_in">GetWaitNext</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      move_to = move_to-&gt;<span class="built_in">GetWaitNext</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    move_to-&gt;<span class="built_in">SetWaitNext</span>(to_move);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Object内部有shadow$_monitor_字段，其在native层对应的是一个LockWord。</li>
<li>LockWord是一个32位的无符号数，根据状态可分为thin、fat、hash、forwarding address状态。</li>
<li>synchronized加锁时，会根据lock_word_的状态，首先尝试使用自旋的方式进行加锁。</li>
<li>如果当前线程是锁的owner，则自旋次数超过LockWord::kThinLockMaxCount次后进行锁膨胀。</li>
<li>如果当前线程不是锁的owner，则自旋次数超过kExtraSpinIters后，会首先尝试将当前线程放到线程调度队列最后短暂让出CPU的方式进行休眠，如果多次后依然无法获取锁，并且次数已经超过了kExtraSpinIters+runtiem-&gt;GetMaxSpinsBeforeThinLockInflation，则进行锁的膨胀。</li>
<li>锁膨胀时会挂起线程，修改lock_word_的状态为fat，同时在MonitorPool中生成Monitor并关联到当前object和线程。</li>
<li>膨胀后的加锁和解锁分别用的是Monitor::Lock和Monitor::Unlock，其内部实现方式是用的Linux Futex系统调用。</li>
<li>在Monitor::Unlock的时候会通知其他处于wake_list_的线程并逐个唤醒。</li>
<li>Object.wait()调用后会进行锁膨胀，线程通过GetWaitConditionVariable()获取的锁进行wait()休眠，并将当前线程加入到monitor的。wait_list_中，然后释放monitor_lock_，让其他线程有机会拿到monitor_lock_进入synchronized块内执行，在被唤醒后会重新获取monitor_lock_。</li>
<li>Object.notify()和Object.notifyAll()只是将线程从wait_list_中移动到wake_list_中，真正进行唤醒其他线程的逻辑是在monitorExit的时候和Object.wait()中调用Monitor::SignalWaiterAndReleaseMonitorLock()时候对其他线程进行唤醒。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/ART/" rel="tag"># ART</a>
              <a href="/tags/Thread/" rel="tag"># Thread</a>
              <a href="/tags/Synchronized/" rel="tag"># Synchronized</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/03/31/debian-install-space-vim/" rel="prev" title="Debian配置SpaceVim">
                  <i class="fa fa-chevron-left"></i> Debian配置SpaceVim
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/01/art-java-dynamic-proxy-explore/" rel="next" title="Android ART 动态代理探究">
                  Android ART 动态代理探究 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘相鑫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
